Every permutation can be represented as a set of cycles.

Maximum:

This is the easier case. Greedy works, some careful implementation and it's ok. Answer is usually 2k in this case, but not always.

Minimum:

If there are such cycles c1, c2, ... cm of length a1, a2, ..., an that a1 + a2 + ... + an = K, then K it's enough. Otherwise the result can be K + 1.

We would like to use knapsack to check it. However, the constraints are too big in this case for a normal knapsack.

We will choose some parameter T and process all numbers bigger than T normally. If there are w such elements, then complexity of this step is . There can be at most numbers bigger than T, so it's .

What should we do with numbers smaller than T? We'll process all numbers of the same type at once. When processing number of type x, we will maintain array c[] which denotes "how many numbers of type x are neccessary to have a certain number knapsack-possible. This step works in O(k·T).

Complexity : O(k·T + ). We should choose such T that this value is minimum possible. T = 100 seems reasonable.

The situation described in a problem is a possible one. There is a tradition in Poland that we give our friends or schoolmates gifts during Christmas. 




Contest Results


First, let's get an intuitive sense for what actually happens in each day. 
Intuitively, Farmer John would always want to add milk to the bottles currently
with the most milk. This is because (m+1)2−m2=2m+1(m+1)2−m2=2m+1 increases as mm
increases. 
Similarly, Farmer Nhoj would intuitively want to remove milk from the highest
bottles he can remove the milk from. This, by the same logic, decreases the
amount of profit Farmer John can make by the highest amount. A proof sketch is included at the bottom of this analysis.
Thus, each day, it turns out that if we sort the array, the bottles indexed from
N−A+1N−A+1 to N−BN−B will gain one unit of milk. We will refer to this as the
interval from now on. 
Subtask 1:
It remains to efficiently simulate this process. When NN and DD are
sufficiently small,  as in this subtask, we can simply sort the array in each
iteration and simulate Farmer John and Farmer Nhoj's moves. 

Subtask 2:
To optimize this, let's consider the structure of the sorted array during each
day. 
We can observe that most of the time, the sorted order of the array does not
change much. In fact,  the only times the sorted order of the array changes is
when the rightmost part of the  interval ``catches up" with the element to the
right of the interval. 
To characterize this, let's call the group of elements on the right of our
interval whose values are the same the borderborder, and we say that kk of
them are activated if the intersection of the border and our interval as length
kk. 
Then, each day, 
All values within our interval AND to the left of the border will increase
by one. The kk smallest elements within the border increase by 11. The border will expand to include all elements to the left and right whose
values are the same as the smallest element in the border.  Specifically, if an
element to the left (within the interval) is added, kk increases by 11. 
To implement this, we just need to keep track of the left and right endpoints of
the border,  the smallest element of the border (we can call it numnum), and the
number of elements in the border whose value is num+1num+1 (we can call it pp). We
can implicitly store all of the values within our interval and to the left of
the border as m[i]+tm[i]+t, where tt is the time that has already elapsed. We can
increase the kk smallest elements by simply updating our values for numnum and
pp,  and we can update our border by simply checking to the left and right of
our border.
The runtime becomes O(NlogN+D)O(Nlog⁡N+D) with sorting. 
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAX_N = 2e5+5;
const ll MOD = 1e9+7;

ll n, d, a, b, l, r;
ll c[MAX_N];

int main(int argc, const char * argv[]){
    cin.tie(0)->sync_with_stdio(0);
    cin.exceptions(cin.failbit);
    cin >> n >> d >> a >> b;
    for(int i = 0; i < n; i++) cin >> c[i];
    sort(c, c+n);
    l = n-a, r = n-b-1;
    ll ql = r, qr = r;
    while(ql > 0 && c[ql-1] == c[r]) ql--;
    while(qr+1 < n && c[qr+1] == c[r]) qr++;
    ll p = 0, num = c[r];
    for(int k = 0; k < d; k++){
        ll x = (r-ql+1)+p;
        num += x/(qr-ql+1), p = x%(qr-ql+1);
        while(qr+1 < n && c[qr+1] == num) qr++;
        while(ql > l && c[ql-1]+k+1 == num) ql--;
    }
    for(int i = l; i < ql; i++) c[i] += d;
    for(int i = ql; i <= qr; i++) c[i] = qr-i < p ? num+1 : num;
    ll ans = 0;
    for(int i = 0; i < n; i++)
        ans = (ans+(c[i]%MOD)*(c[i]%MOD))%MOD;
    cout << ans << '\n';
    return 0;
}


Full Solution
Instead of iterating over each day individually, let's calculate the next time
our  border changes. 
Our border can only ever expand, so we can simply calculate the time when the
border will expand to the  left, and when our border would expand to the right,
and take the earlier one. 
To do this, let's take another look at how the border's values grow. Clearly,
the  sum of the values within the border grows by kk each day; in fact, it is
pretty easy to then derive that 
num=⌊Σ/length(border)⌋,p=Σmodlength(border)num=⌊Σ/length(border)⌋,p=Σmodlength(border)
Thus, the first time numnum will exceed a certain theshold MM (the element to
the right of the border) is 
⌈(M−num)⋅length(border)−pk⌉⌈(M−num)⋅length(border)−pk⌉
Similarly, we can do some algebra to obtain the minimum time for the border to
expand on the left:
⌊(num−M−t)⋅length(border)+plength(border)−k⌋⌊(num−M−t)⋅length(border)+plength(border)−k⌋
Once we've calculated these times, we can update our values accordingly and
expand the border. 
Since the border can only expand at most O(N)O(N) times,  this process can only
occur at most O(N)O(N) times. So, with sorting, the overall runtime is
O(NlogN)O(Nlog⁡N).
Larry's Code:
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define ff first
#define ss second
const int MAX_N = 2e5+5;
const ll MOD = 1e9+7;
const ll INF = 1e18;

ll n, d, a, b, l, r;
ll c[MAX_N];

ll ceil(ll a, ll b){
    return (a+b-1)/b;
}

int main(int argc, const char * argv[]){
    cin.tie(0)->sync_with_stdio(0);
    cin.exceptions(cin.failbit);
    cin >> n >> d >> a >> b;
    for(int i = 0; i < n; i++) cin >> c[i];
    sort(c, c+n);
    l = n-a, r = n-b-1;
    ll ql = r, qr = r;
    while(ql > l && c[ql-1] == c[r]) ql--;
    while(qr+1 < n && c[qr+1] == c[r]) qr++;
    ll k = 0, p = 0, num = c[r];
    while(true){
        ll numx = qr+1 < n ? ceil((c[qr+1]-num)*(qr-ql+1)-p, r-ql+1) : INF;
        ll numy = ql > l && r != qr ? ((qr-ql+1)*(num-(c[ql-1]+k))+p)/(qr-r) : INF;
        if(k+min(numx, numy) > d) break;
        ll x = min(numx, numy)*(r-ql+1)+p;
        num += x/(qr-ql+1), p = x%(qr-ql+1), k += min(numx, numy);
        while(qr+1 < n && c[qr+1] == num) qr++;
        while(ql > l && c[ql-1]+k == num) ql--;
    }
    ll x = ((d-k)*(r-ql+1)+p)/(qr-ql+1), y = (d-k)*(r-ql+1)+p-x*(qr-ql+1);
    num += ((d-k)*(r-ql+1)+p)/(qr-ql+1), p = y, k = d;
    for(int i = l; i < ql; i++) c[i] += d;
    for(int i = ql; i <= qr; i++) c[i] = qr-i < p ? num+1 : num;
    ll ans = 0;
    for(int i = 0; i < n; i++)
        ans = (ans+(c[i]%MOD)*(c[i]%MOD))%MOD;
    cout << ans << '\n';
    return 0;
}

Alternatively, you can model the values within the border as fractions. At any
time, the values within the interval and not in the border increase at a steady
rate of 11 unit of milk per day,  and the values within the border increase at
a steady rate of k/length(border)k/length(border) per day. 
Storing each of these as fractions, we can greatly simplify our transitions. 
Eric's Code: 
import sys
from fractions import Fraction
import math
 
input = sys.stdin.readline
 
N, D = map(int, input().split())
A, B = map(int, input().split())
M = list(sorted(map(int, input().split())))
 
constant = M[:N-A]
V = M[N-A:]
 
C = A-B
 
assert C > 0
 
border_value = V[C-1]
border_min = C-1
border_max = C-1
 
ct = 0
 
def expand_border():
    global border_min, border_max
    while border_min > 0 and V[border_min-1] + ct == border_value:
        border_min -= 1
    while border_max < A-1 and V[border_max+1] == border_value:
        border_max += 1
 
while ct < D:
    expand_border()
    delta_to_min = Fraction(1000000000, 1)
    delta_to_max = Fraction(1000000000, 1)
    num_border = border_max - border_min + 1
    alloc_to_border = C - border_min
    border_rate = Fraction(alloc_to_border, num_border)
    if border_min > 0:
        val = V[border_min-1] + ct
        if val == border_value:
            delta_to_min = Fraction(0, 1)
        elif border_rate < 1:
            delta_to_min = Fraction((border_value - val), 1 - border_rate)
    if border_max < A-1:
        val = V[border_max+1]
        if val == border_value:
            delta_to_max = Fraction(0, 1)
        elif border_rate > 0:
            delta_to_max = Fraction((val - border_value), border_rate)
    delta = min(delta_to_min, delta_to_max)
    if ct + delta >= D:
        delta = D - ct
    border_value += border_rate * delta
    ct += delta
 
assert ct == D
 
ans = 0
for m in constant:
    ans += m * m
for m in V[:border_min]:
    ans += (m+ct) * (m+ct)
for m in V[border_max+1:]:
    ans += m * m
 
num_border = border_max - border_min + 1
floor_value = math.floor(border_value)
num_ceil = 0
while floor_value < border_value:
    floor_value += Fraction(1, num_border)
    num_ceil += 1
 
assert floor_value == border_value
 
ans += pow(math.floor(border_value), 2) * (num_border - num_ceil)
ans += pow(math.ceil(border_value), 2) * num_ceil
 
print(ans % (10 ** 9 + 7))

Note: The complexity of this solution is difficult to analyze, since the size of
the denominator may contribute to the time complexity. However, it is possible
to show that the denominator is at most N⋅DN⋅D,  so the solution comfortably
runs in time. 

Proof Sketch
Model the problem as a two-player game. A game state consists of the array of
milk values. A move consists of either Farmer John or Farmer Nhoj performing
their action. 
For two game states xx and yy, x≻yx≻y means xx majorizes yy, or that
for all kk, the sum of the kk largest elements of xx is ≥≥ the kk largest
elements of yy. Additionally, the sums of xx and yy must be equal.
Equivalently, xx majorizes yy iff xx can be transformed into yy by
repeatedly performing one of the following operations on xx:
Permute xx arbitrarily.Move one unit of milk from a bottle with more milk to a bottle with less
milk.
Our goal is to show for all mm that if x≻yx≻y, then
final_profitm(x)≥final_profitm(y)final_profitm(x)≥final_profitm(y). We proceed by induction
on mm, the number of moves remaining (0≤m≤2D0≤m≤2D). 
Base case: For m=0m=0, if x≻yx≻y, then by
Karamata's
inequality,
final_profit0(x)=∑x2i≥∑y2i=final_profit0(y)final_profit0(x)=∑xi2≥∑yi2=final_profit0(y).
Inductive step: Assume that the inductive hypothesis holds if m−1m−1 moves
remain, for 1≤m≤2D1≤m≤2D.  We would like to show that the hypothesis holds for
mm moves remaining.
Suppose it is Farmer John to move, and that the state before the move was
xx.  Let move_largest(x)move_largest(x) represent the state of xx after adding 1 to
the AA largest bottles and move(x)move(x) represent any possible state of xx
after FJ moves. Clearly move_largest(x)≻move(x)move_largest(x)≻move(x), and for
any state yy such that x≻yx≻y,
move_largest(x)≻move_largest(y)move_largest(x)≻move_largest(y).  So 
final_profitm(x)=final_profitm−1(move_largest(x))≥final_profitm−1(move_largest(y))=final_profitm(y),final_profitm(x)=final_profitm−1(move_largest(x))≥final_profitm−1(move_largest(y))=final_profitm(y),
implying that the inductive hypothesis holds for mm.
On the other hand, suppose it is Farmer Nhoj to move. Similarly, let
move_largestmove_largest represent subtracting 1 from the BB largest bottles and
movemove represent any possible move. It may be shown that
move_largest(x)≺move(x)move_largest(x)≺move(x). Also, we claim that for any state
yy such that x≺yx≺y, move_largest(x)≺move_largest(y)move_largest(x)≺move_largest(y)
(left as an exercise to the reader). This claim is harder to show than in the
case where it is Farmer John to move since the sorted order of the bottles may
change after Farmer Nhoj moves. However, keep in mind that we only need to show
that it holds when xx and yy differ by only a single operation of type 2,
after which it naturally extends to the case where xx and yy differ by
multiple operations of type 2.
Assuming the above,
final_profitm(x)=final_profitm−1(move_largest(x))≤final_profitm−1(move_largest(y))=final_profitm(y),final_profitm(x)=final_profitm−1(move_largest(x))≤final_profitm−1(move_largest(y))=final_profitm(y),
implying that the inductive hypothesis holds for mm.
(Note that it is always possible for Farmer Nhoj to make move_largestmove_largest,
since A>BA>B.)





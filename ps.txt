 Observation:  Let's denote an integer kk as the maximum number of
occurrences of any integer in array aa. Let cnticnti denote the number of times
that integer ii occurs in aa. We can choose xx and yy as the two head cows
if and only if cntxcntx and cntycnty are both nonzero and cntx+cnty≥kcntx+cnty≥k.
Why? Consider an integer zz that occurs kk times in aa and we want to check
if cows pp and qq can be the two new head cows. We can place all ai=pai=p
into set SS and none of ai=qai=q into SS. Then, we can place cntpcntp
occurrences of ai=zai=z into SS, leaving k−cntpk−cntp occurrences of ai=zai=z
outside SS.  Clearly, we can choose cow pp as cow xx and if we place one more
occurrence of ai=zai=z into SS, we cannot choose cow pp anymore. Now we only
have to ensure there are at most cntqcntq occurrences of ai=zai=z outside SS so
that we can choose cow qq, leaving the inequality k−cntp≤cntqk−cntp≤cntq.
Therefore, the problem boils down to: Find two integers pp and qq such that
cntpcntp and cntqcntq are both nonzero, cntp+cntq≥kcntp+cntq≥k, and |p−q||p−q| is
maximized.
Subtask 22: N,Q≤3000N,Q≤3000. 
This can be solved using suffix maximums in O(NQ)O(NQ) time. For each
integer dd, if we know the maximum integer that occurs at least dd times, we
know the other head cow must be the smallest integer that occurs at least
k−dk−d times.
 Full Credit: 
The essential observation is: There exist at most 2N−−−√2N distinct values in
array cntcnt.
Consider the worst case, that is, cnt=[1,2,3,,m,0,0,,0]cnt=[1,2,3,,m,0,0,,0].
We know that ∑mi=1cnti=N∑i=1mcnti=N, so m⋅(m+1)2=Nm⋅(m+1)2=N. From
this, we can deduce that mm must be at most 2N−−−√2N.  
With this observation, we can realize that we only need to track the maximum and
minimum elements of each distinct frequency that appears. Then, we can use the
solution from the previous subtask. Given frequency dd, to find the least
frequency k−dk−d that appears, we can use two pointers.
The time complexity is O(NlogN+QN−−√)O(Nlog⁡N+QN).
#include <bits/stdc++.h>
using namespace std;
 
int main(){
	cin.tie(0) -> sync_with_stdio(0);
	int n, q; cin >> n >> q;
	vector<int> a(n);
	for(int i = 0; i < n; i++) cin >> a[i];
	vector<int> cnt(n+1);
	map<int, int> freq_mp; // freq_mp[i] stores the number of integers with occurrence i
	vector<set<int>> freqs(n+1); // freqs[i] stores a set of integers with occurrence i
	
	for(int i: a){
		cnt[i]++;
	}
	for(int i = 1; i <= n; i++){
		freq_mp[cnt[i]]++;
		freqs[cnt[i]].insert(i);
	}
	
	// change cnt[x] by c
	auto change = [&](int x, int c) -> void {
		freq_mp[cnt[x]]--;	
		if(!freq_mp[cnt[x]]) 
			freq_mp.erase(cnt[x]);
		freqs[cnt[x]].erase(x);
		cnt[x] += c;
		freq_mp[cnt[x]]++;
		freqs[cnt[x]].insert(x);
	};
	
	while(q--){
		int idx, x; cin >> idx >> x;
		idx--;
		change(a[idx], -1);
		a[idx] = x;
		change(a[idx], 1);
		
		vector<int> distinct_freqs;
		for(auto i: freq_mp){
			if(i.first){
				distinct_freqs.push_back(i.first);
			}
		}
		int m = distinct_freqs.size(); // m is at most approx sqrt(n)
		int mode_freq = distinct_freqs.back();
		
		vector<int> min_freq(m), max_freq(m); // max and min numbers with each frequency
		for(int i = 0; i < m; i++){
			min_freq[i] = *freqs[distinct_freqs[i]].begin();
			max_freq[i] = *freqs[distinct_freqs[i]].rbegin();
		}
		
		for(int i = m - 2; i >= 0; i--){
			max_freq[i] = max(max_freq[i], max_freq[i+1]);
		}
		
		int ans = 0;
		for(int l = 0, r = m - 1; l < m; l++){
			while(r - 1 >= 0 && distinct_freqs[r-1] + distinct_freqs[l] >= mode_freq){
				r--;
			}
			ans = max(ans, abs(max_freq[r] - min_freq[l]));
		}
		
		cout << ans << "\n";
	}
}
 
/*   /\_/\
*   (= ._.)
*   / >  \>
*/







cod:
```
#include <bits/stdc++.h>
#define int long long
using namespace std;
 
int mod = 1e6+3;
 
vector<int> fact(mod);
 
int inv(int a){
    return a <= 1 ? a : mod - mod / a * inv(mod % a) % mod;
}
 
void solve(){
    int n, x, ans = 1;
    cin >> n;
    vector<int> a(n), b(n);
    for(int i=0; i<n; i++)
        cin >> a[i];
    for(int i=0; i<n; i++)
        cin >> b[i];
    int k = __lg(b[0] / a[0]);
    for(int i=1; i<n; i++)
        k = min(k, __lg(b[i] / a[i]));
    x = k;
    vector<int> cnt(k), c(n);
    for(int i=0; i<n; i++){
        for(int j=0; j<k; j++){
            cnt[j] += b[i] & 1;
            b[i] >>= 1;
        }
        c[i] = b[i] - a[i];
    }
    for(int j=0; j<k; j++){
        x += cnt[j];
        ans = ans * fact[cnt[j]] % mod;
    }
    int last = accumulate(c.begin(), c.end(), 0LL);
    ans = (last < mod ? ans * fact[last] % mod : 0);
    for(int i : c){
        x += i;
        ans = ans * inv(fact[i]) % mod;
    }
    cout << x << ' ' << ans << '\n';
}
 
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    fact[0] = 1;
    for(int i=1; i<mod; i++) fact[i] = fact[i-1] * i % mod;
    int t;
    cin >> t;
    while(t--) solve();
}
```

Let's fix the number of double operations we use; call this integer k

. Now, we can treat each value independently.
Step 2

Consider a specific pair ai,bi
. If we don't apply any addition operations, we have that ai becomes ai⋅2k. Clearly we need that ai⋅2k≤bi. Now, observe that applying an addition operation before applying j of the k double operations is equivalent to adding 2j to our final sum. We need to add bi−ai⋅2k, so in total, we apply ⌊bi−ai⋅2k2k⌋=⌊bi2k⌋−ai addition operations at the beginning, each adding 2k to our sum. Then, we apply popcount((bi−ai⋅2k)(mod2k))=popcount(bi(mod2k)) addition operations later, where popcount(x) denotes the number of set bits in x. This is because, if the j-th bit of bi−ai⋅2k is set for some j<k, we would like to apply an operation before applying j of the double operations so we can add 2j

to our sum.
Step 3

We would like to choose the largest number of double operations possible, since a double operation increases all values by at least one. Furthermore, since n≥2
, a double operation is strictly more effective than an addition operation. However, we still need to satisfy ai⋅2k≤bi for all i. Therefore, we will choose k=minlog2biai

.
Step 4

Between each double operation, the addition operations can be rearranged. Let's consider all of the addition operations applied before applying exactly j
double operations; denote these values c1,…,cn, where ci is the number of addition operations performed on element ai. Then we can multiply our number of sequences by (∑cic1,…,cn), the multinomial coefficient of ci. This is equal to (∑ci)!∏(ci!). To simplify implementation, note that for j<k, all ci are either 0 or 1, so the denominator is only nontrivial for j=k. The final answer is the product of these values across all 0≤j≤k. See the next section for intuition on multinomial coefficients and some of the details on its implementation.

The intuition behind the formula for multinomial coefficients is as follows: let's say n=3, and we want to find the number of ways to color ∑ci balls such that c1 are red, c2 are green, and c3 are blue. Let's call our positions "red 1" … "red c1" … "blue c3". Now, it's clear that there are (∑ci)! ways to assign each ball to a position, because we have ∑ci choices of balls to assign to "red 1", then ∑ci−1 remaining choices of balls to assign to "red 2", and so forth, until we only have one choice of balls to assign to "blue c3". However, this overcounts, because there is no difference between assigning ball 1 to "red 1" and ball 2 to "red 2", and vice versa. We are overcounting the red assignments by a factor of c1!, because every valid selection of red balls achieves c1! assignments of red balls to positions. Similar reasoning holds for the green and blue balls, so in total, we have (∑ci)!∏(ci!)

different sequences.

Multinomial coefficients can be computed by precomputing factorials. For the numerator, note that if ∑ci≥106+3
then (∑ci)!≡0(mod106+3) because we have a factor of 106+3, so we only need to precompute factorials up to 106+2. For the denominator, we can divide by ci! by multiplying by the modular inverse of ci! modulo 106+3. Crucially, note that ci<106+3 because the number of addition operations you can apply is at most bi−ai<106, so modular inverses are well-defined. 

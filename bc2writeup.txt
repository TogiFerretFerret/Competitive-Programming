snowball effect (prefix sums) (i didn't do it strictly with prefix at the time tho bc i didnt realize it then that it was purely prefix sums)
the winner's new skill is always the sum of the two cows fighting.
if you fight normally and win, you absorb the loser's skill.
if  you lose and cheat, you stay in line and absorb the winner's skill.
so regardless of cheats, a survivor at any point always has a skill equal to the prefix sum of everyone processed so far.
so you only need to use a cheat against opponent j if a[j]>sum of all previous cows including you
for solving move right (inserting later) - easier case
you let the prefix of cows 1 to p grow without you; if the sum is bigger than you (s[p]>=a[i]), you need 1 cheat to enter
suffix check: once you enter, you join the snowball (prefix). any opponent j ahead of you only requires a cheat if a[j]>s[j-1]
these inherently dangerous cows depend only on the array a, not your skill. i used binary search on precompute suffix counts to find how far right you can start while having enough cheats left.

for move left (inserting earlier)
harder bc whether an opponent is in the middle is dangerous depends on your specific skill added to the pile
the condition is an opponent at index j where j<current pos (cpos) requires a chef if a[j]>s[j-1]+a[i] ; rearrange, they are a threat if a[j]-s[j-1]>a[i]
the abstraction: we treat every position j as an obstacle with diff d[j]=a[j] - s[j-1]
we need to pick a start pos p such that the count of obstacles between p and current spot (where d[j]>a[i] is small enough to fit our budget k

why binary index tree:
since the condition d[j]>a[i] changes for every cow a standard check is too slow (o(n^2))
offline processing: sortd all queries (coes) by skill a[i] from largest to smallest. sorted all obstacles by diff d[j]
sweep line: as i process smaller and smaller a[i], more obstacles become "dangerous". i insert these new dangerous positions into the bit
binary search on bit: now, for the current cow, the bit contains a 1 at every index that forces a cheat. we need to find the rightmost start position p so the sum in range bit.query(p, current) <= k. since sums in a bit are monotonic, we can use binary lifting (efficient binary search) to find this index in o(log n)
